转自：本文出自Bin的专栏blog.csdn.net/xbinworld
https://blog.csdn.net/xbinworld/article/details/76408595

1.	特点：双调排序是data-independent的排序， 即比较顺序与数据无关的排序方法，特别适合做并行计算

2.	定义：双调序列是一个先单调递增后单调递减（或者先单调递减后单调递增）的序列。

3.	理论基础：Batcher定理
将任意一个长为2n的双调序列A分为等长的两半X和Y，将X中的元素与Y中的元素一一按原序比较，即a[i]与a[i+n] (i < n)比较，将较大者放入MAX序列，较小者放入MIN序列。则得到的MAX和MIN序列仍然是双调序列，并且MAX序列中的任意一个元素不小于MIN序列中的任意一个元素。

4.	原理：
对一个双调序列，根据Batcher定理，可以先把它从中间一分为二，得到两个单调序列；再比较两个单调序列对应位置上的元素，并进行交换，得到2个新的双调序列（1个先增后减、1个先减后增），然后继续对这2个双调序列进行递归划分、交换位置，得到更短的序列，直到得到的子序列长度为1。这时的输出序列按单调递增排序。

升序排序，具体方法是，把一个序列(1…n)对半分，假设n=2^k，然后1和n/2+1比较，小的放上，接下来2和n/2+2比较，小的放上，以此类推；得到两个(n/2)长度的序列，因为他们都是双调序列，所以可以重复上面的过程；总共重复k轮，即最后一轮已经是长度是2的序列比较了，就可得到最终的排序结果。

5.	生成双调序列
生成双调序列的过程叫Bitonic merge, 实际上也是divide and conquer的思路。
和前面sort的思路正相反，是一个bottom up的过程——将两个相邻的，单调性相反的单调序列看作一个双调序列，每次将这两个相邻的，单调性相反的单调序列merge生成一个新的双调序列，然后排序。（这里是batcher定理的反向应用）

这样只要每次两个相邻长度为n的序列的单调性相反，就可以通过连接得到一个长度为2n的双调序列，然后对这个2n的序列进行一次双调排序变成有序，然后在把两个相邻的2n序列合并（在排序的时候第一个升序，第二个降序）。 n开始为1， 每次翻倍，直到等于数组长度， 最后就只需要再一遍单方向（单调性）排序了。



算法个人理解：
原始未排序的序列
5	2	1	7	3	8	6	4

第一步，每两个元素组成一个序列并排序，使相邻序列的单调性完全相反，得到：
[2	5]		[7	1]		[3	8]		[6	4]
其中，[2、5]为升序，[7、1]为降序，[3、8]为升序，[6、4]为降序

第二步，将上一步得到的序列，对应位置的元素分别进行比较，按升序或降序交换位置，
对于序列[2 5]和[7 1]，采用升序比较。将2和7比较，因为2比7小，不用交换；5和1比较，1比5小，于是1交换到前1序列里，得到[2	1]和[7 5]
对于序列[3 8]和[6 4]，采用降序比较。将3和6比较，因为6比3大，于是把6交换到前1序列；8和4比较，8比4大，不用交换。得到[6 8]和[3 4]
[2	1]	[7	5]	[6	8]	[3	4]

然后每2个元素分别排序一次，就能把每4个元素排序成一个单调序列，整体8个元素组成了一个双调序列
[1	2	5	7]	[8	6	4	3]

第三步：按照上一步的做法，先把两个单调性相反的序列的对应位置元素分别进行比较和交换位置，得到
[1	2	4	3]	[8	6	5	7]

然后在每个序列内部，分成上下两段，再对应位置按升序比较、交换位置
[1	2]	[4	3]	[5	6]	[8	7]

最后再在每个序列内部，分成上下两段，再对应位置按升序比较、交换位置，得到
[1] [2] [3] [4] [5] [6] [7] [8]


读懂网页里的图：
箭头的头和尾代表参与比较的两个元素，向下的箭头代表按升序排序/交换位置，向上的箭头代表按降序序排序/交换元素位置。

实现代码可参考：https://blog.csdn.net/abcjennifer/article/details/47110991

