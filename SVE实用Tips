1.	在相同的条件下，_m要比_z指令要快。
2.	svdup占用时间，如果变量是常数的话尽可能放在循环外，定义一个const svfloat_t VEC =svdup_f32(x)；在循环内调用VEC。

1.	const常量定义在函数体外（全局常量，前面加static），与定义在函数体内（局部常量），两者编译出来的.s文件没有区别，建议统一放到函数体内；
2.	某些情况下，opencv的Neon版本为了实现某一功能用了多条指令，用SVE intrinsic改写时，只需要一条指令就能实现同样的功能，
因此，有必要仔细阅读SVE官方指令文档，看是否有更加方便的单条指令进行多条指令替换，例如exp指数计算用到的svscale指令
3.	svaddv、svminv等指令效率较低，尽量不要在循环体内多次调用，最好在循环体内用 别的指令来计算中间结果，最后到循环体外再调用一次svaddv、svminv等；
4.	大多数情况下，向量与标量进行计算，向量与常数向量进行计算，这两者的效率没有明显区别；
5.	带有控制流的c/c++循环语句，改写成SVE intrinsic，效率提升会打折扣；且控制流操作可能难以从循环体中提取出来；
6.	SVE算子循环体中的unroll写法，对某些算子能起到性能优化的作用，但不是对每个算子都能起作用
7.  如果要统计函数运行时间，需要在编译时用-O3选项
8.  expa指令比svld1_gather_index指令要慢
9.  C版本的程序比C++版本稍快，运行时间减少约5%

1.  _x指令的性能优于_z与_m，在逻辑允许的情况下尽量用_x
2.	凡是reduce操作(将个sv向量转化成标量)性能都很慢，例如svadda还不如直接for循环相加.
3.	含有mask的函数不容易开发。
4.	取指针的操作最快的是arr+=step，不要用&arr[i]
5.	涉及类型转换最快的方法目前是svld1uw_u64+reinterpret+svcvt，根据实际情况的不同还有svld(array) + svld(nextArray) +svcvt; 或者svld + unpack + svcvt + svuzp.
6.	简单算子的优化反而更加困难，因为load和store耗时占比太大。
